// Application Class Loader ищет именованные модули ранее определенные, если находит, то загружает иначе делегирует родителю.
// Делегирование при отсутствии данного класса происходит от потомка к родителю.
// В нашем случае изначально класс не определн нигде, также ни Bootstrap ClassLoader ни Platform ClassLoader не загрузят этот класс, в итоге его загрузит Application Class Loader, как пользовательский класс.
 
public class JvmComprehension {
 
    // Создается в стеке фрейм функциц main.
    public static void main(String[] args) {
        int i = 1;                      // Создается в стеке переменная i типа int.
        Object o = new Object();        // Создается объект типа Object в куче, и в стеке создается ссылка на этот объект.
        Integer ii = 2;                 // Создается объект типа Integer в куче, и в стеке создается ссылка на этот объект.
        printAll(o, i, ii);             // Создается в стеке фрейм функции printAll
        System.out.println("finished"); // В стеке создается новый фрейм и в нем создается ссылка на созданный в куче строковый объект. 
    }
 
    private static void printAll(Object o, int i, Integer ii) { 
        // Создается фрейм в стеке, и в нем создаются копии ссылок на объекты o, ii из кучи.
        // Также в этом фрейме создается копия переменной i.
        Integer uselessVar = 700;                   // Создается объект типа Integer в куче, и в стеке создается ссылка на него. 
        System.out.println(o.toString() + i + ii);  // Создается новый фрейм в стеке, куда передаются ссылки на объекты и копия переменной i. 
    }
}
